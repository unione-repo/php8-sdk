<?php
/**
 * WebhookSetJsonPostRequestEventsByUserInnerEventsInnerEventData
 *
 * PHP version 8.1
 *
 * @package  UniOne
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Web API
 *
 * All UniOne API methods require HTTPS connection. UniOne accepts HTTP POST requests in JSON format up to 10 megabytes long and returns HTTP response also in JSON. API endpoint (or base URL) depends on which datacenter the user is registered at.<br>You can use https://eu1.unione.io/en/transactional/api/v1 or https://us1.unione.io/en/transactional/api/v1 directly.
 *
 * The version of the OpenAPI document: 1.76
 * @generated Generated by: https://openapi-generator.tech
 * Generator version: 7.19.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace UniOne\Model;

use ArrayAccess;
use JsonSerializable;
use InvalidArgumentException;
use ReturnTypeWillChange;
use UniOne\ObjectSerializer;

/**
 * WebhookSetJsonPostRequestEventsByUserInnerEventsInnerEventData Class Doc Comment
 *
 * @description Object with different event properties depending on **event_name**. Below you can see all the properties, **transactional_email_status**-related first and then **transactional_spam_block**-related.
 * @package  UniOne
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements ArrayAccess<string, mixed>
 */
class WebhookSetJsonPostRequestEventsByUserInnerEventsInnerEventData implements ModelInterface, ArrayAccess, JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static string $openAPIModelName = '_webhook_set_json_post_request_events_by_user_inner_events_inner_event_data';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var array<string, string>
      */
    protected static array $openAPITypes = [
        'jobId' => 'string',
        'metadata' => 'array<string,string>',
        'email' => 'string',
        'status' => 'string',
        'eventTime' => 'string',
        'url' => 'string',
        'deliveryInfo' => '\UniOne\Model\WebhookSetJsonPostRequestEventsByUserInnerEventsInnerEventDataDeliveryInfo',
        'blockTime' => 'string',
        'blockType' => 'string',
        'domain' => 'string',
        'sMTPBlocksCount' => 'int',
        'domainStatus' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var array<string, string|null>
      */
    protected static array $openAPIFormats = [
        'jobId' => null,
        'metadata' => null,
        'email' => 'email',
        'status' => null,
        'eventTime' => 'utc-date-time',
        'url' => 'uri',
        'deliveryInfo' => null,
        'blockTime' => 'utc-date-time',
        'blockType' => null,
        'domain' => null,
        'sMTPBlocksCount' => null,
        'domainStatus' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var array<string, bool>
      */
    protected static array $openAPINullables = [
        'jobId' => false,
        'metadata' => false,
        'email' => false,
        'status' => false,
        'eventTime' => false,
        'url' => false,
        'deliveryInfo' => false,
        'blockTime' => false,
        'blockType' => false,
        'domain' => false,
        'sMTPBlocksCount' => false,
        'domainStatus' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var array<string, bool>
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array<string, string>
     */
    public static function openAPITypes(): array
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array<string, string>
     */
    public static function openAPIFormats(): array
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array<string, bool>
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return array<string, bool>
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param array<string, bool> $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var array<string, string>
     */
    protected static array $attributeMap = [
        'jobId' => 'job_id',
        'metadata' => 'metadata',
        'email' => 'email',
        'status' => 'status',
        'eventTime' => 'event_time',
        'url' => 'url',
        'deliveryInfo' => 'delivery_info',
        'blockTime' => 'block_time',
        'blockType' => 'block_type',
        'domain' => 'domain',
        'sMTPBlocksCount' => 'SMTP_blocks_count',
        'domainStatus' => 'domain_status'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var array<string, string>
     */
    protected static array $setters = [
        'jobId' => 'setJobId',
        'metadata' => 'setMetadata',
        'email' => 'setEmail',
        'status' => 'setStatus',
        'eventTime' => 'setEventTime',
        'url' => 'setUrl',
        'deliveryInfo' => 'setDeliveryInfo',
        'blockTime' => 'setBlockTime',
        'blockType' => 'setBlockType',
        'domain' => 'setDomain',
        'sMTPBlocksCount' => 'setSMTPBlocksCount',
        'domainStatus' => 'setDomainStatus'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var array<string, string>
     */
    protected static array $getters = [
        'jobId' => 'getJobId',
        'metadata' => 'getMetadata',
        'email' => 'getEmail',
        'status' => 'getStatus',
        'eventTime' => 'getEventTime',
        'url' => 'getUrl',
        'deliveryInfo' => 'getDeliveryInfo',
        'blockTime' => 'getBlockTime',
        'blockType' => 'getBlockType',
        'domain' => 'getDomain',
        'sMTPBlocksCount' => 'getSMTPBlocksCount',
        'domainStatus' => 'getDomainStatus'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array<string, string>
     */
    public static function attributeMap(): array
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array<string, string>
     */
    public static function setters(): array
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array<string, string>
     */
    public static function getters(): array
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName(): string
    {
        return self::$openAPIModelName;
    }

    public const STATUS_SENT = 'sent';
    public const STATUS_DELIVERED = 'delivered';
    public const STATUS_OPENED = 'opened';
    public const STATUS_CLICKED = 'clicked';
    public const STATUS_UNSUBSCRIBED = 'unsubscribed';
    public const STATUS_SUBSCRIBED = 'subscribed';
    public const STATUS_SOFT_BOUNCED = 'soft_bounced';
    public const STATUS_HARD_BOUNCED = 'hard_bounced';
    public const STATUS_SPAM = 'spam';
    public const STATUS_UNKNOWN_DEFAULT_OPEN_API = 'unknown_default_open_api';
    public const BLOCK_TYPE_ONE_SMTP = 'one_smtp';
    public const BLOCK_TYPE_ALL_SMTP = 'all_smtp';
    public const BLOCK_TYPE_UNKNOWN_DEFAULT_OPEN_API = 'unknown_default_open_api';
    public const DOMAIN_STATUS_BLOCKED = 'blocked';
    public const DOMAIN_STATUS_UNBLOCKED = 'unblocked';
    public const DOMAIN_STATUS_UNKNOWN_DEFAULT_OPEN_API = 'unknown_default_open_api';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public static function getStatusAllowableValues()
    {
        return [
            self::STATUS_SENT,
            self::STATUS_DELIVERED,
            self::STATUS_OPENED,
            self::STATUS_CLICKED,
            self::STATUS_UNSUBSCRIBED,
            self::STATUS_SUBSCRIBED,
            self::STATUS_SOFT_BOUNCED,
            self::STATUS_HARD_BOUNCED,
            self::STATUS_SPAM,
            self::STATUS_UNKNOWN_DEFAULT_OPEN_API,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public static function getBlockTypeAllowableValues()
    {
        return [
            self::BLOCK_TYPE_ONE_SMTP,
            self::BLOCK_TYPE_ALL_SMTP,
            self::BLOCK_TYPE_UNKNOWN_DEFAULT_OPEN_API,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public static function getDomainStatusAllowableValues()
    {
        return [
            self::DOMAIN_STATUS_BLOCKED,
            self::DOMAIN_STATUS_UNBLOCKED,
            self::DOMAIN_STATUS_UNKNOWN_DEFAULT_OPEN_API,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var array
     */
    protected array $container = [];

    /**
     * Constructor
     *
     * @param array $data Associated array of property values initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('jobId', $data ?? [], null);
        $this->setIfExists('metadata', $data ?? [], null);
        $this->setIfExists('email', $data ?? [], null);
        $this->setIfExists('status', $data ?? [], null);
        $this->setIfExists('eventTime', $data ?? [], null);
        $this->setIfExists('url', $data ?? [], null);
        $this->setIfExists('deliveryInfo', $data ?? [], null);
        $this->setIfExists('blockTime', $data ?? [], null);
        $this->setIfExists('blockType', $data ?? [], null);
        $this->setIfExists('domain', $data ?? [], null);
        $this->setIfExists('sMTPBlocksCount', $data ?? [], null);
        $this->setIfExists('domainStatus', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, mixed $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return string[] invalid properties with reasons
     */
    public function listInvalidProperties(): array
    {
        $invalidProperties = [];

        $allowedValues = self::getStatusAllowableValues();
        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'status', must be one of '%s'",
                $this->container['status'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = self::getBlockTypeAllowableValues();
        if (!is_null($this->container['blockType']) && !in_array($this->container['blockType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'blockType', must be one of '%s'",
                $this->container['blockType'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = self::getDomainStatusAllowableValues();
        if (!is_null($this->container['domainStatus']) && !in_array($this->container['domainStatus'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'domainStatus', must be one of '%s'",
                $this->container['domainStatus'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid(): bool
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets jobId
     *
     * @return string|null
     */
    public function getJobId(): ?string
    {
        return $this->container['jobId'];
    }

    /**
     * Sets jobId
     *
     * @param string|null $jobId Job identifier returned earlier by [email/send](https://docs.unione.io/en/web-api-ref#email-send) method. Property exists only if event_name=**transactional_email_status**.
     *
     * @return $this
     */
    public function setJobId(?string $jobId): static
    {
        if (is_null($jobId)) {
            throw new InvalidArgumentException('non-nullable jobId cannot be null');
        }
        $this->container['jobId'] = $jobId;

        return $this;
    }

    /**
     * Gets metadata
     *
     * @return array<string,string>|null
     */
    public function getMetadata(): ?array
    {
        return $this->container['metadata'];
    }

    /**
     * Sets metadata
     *
     * @param array<string,string>|null $metadata Metadata passed in [email/send](https://docs.unione.io/en/web-api-ref#email-send) method in recipients.metadata or global_metadata properties. This property exists only if event_name=**transactional_email_status**.
     *
     * @return $this
     */
    public function setMetadata(?array $metadata): static
    {
        if (is_null($metadata)) {
            throw new InvalidArgumentException('non-nullable metadata cannot be null');
        }
        $this->container['metadata'] = $metadata;

        return $this;
    }

    /**
     * Gets email
     *
     * @return string|null
     */
    public function getEmail(): ?string
    {
        return $this->container['email'];
    }

    /**
     * Sets email
     *
     * @param string|null $email Recipient's email. This property exists only if event_name=**transactional_email_status**.
     *
     * @return $this
     */
    public function setEmail(?string $email): static
    {
        if (is_null($email)) {
            throw new InvalidArgumentException('non-nullable email cannot be null');
        }
        $this->container['email'] = $email;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string|null
     */
    public function getStatus(): ?string
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string|null $status Email delivery status. This property exists only if event_name=**transactional_email_status**. Possible values are:<br>__accepted__ — the message has been accepted, but not sent yet.<br>__sent__ — the message has been sent, but not delivered yet.<br>__delivered__ — the message has been delivered. It can be changed to “opened”, “clicked”, “unsubscribed”, “subscribed” or “spam”.<br>__opened__ — the message has been delivered and read. It can be changed to “clicked”, “unsubscribed”, “subscribed” or “spam”.<br>__clicked__ — the message has been delivered, read, and at least one of the links in email has been clicked. It can be changed to “unsubscribed”, “subscribed” or “spam”.<br>__unsubscribed__ — the message has been delivered to the recipient and read, but then the recipient unsubscribed. It can be changed to “subscribed”.<br>__subscribed__ — the message has been delivered to the recipient and read, but then the recipient unsubscribed and subscribed again. It can be changed to “unsubscribed”.<br>__soft_bounced__ — temporary delivery failure. UniOne will try to deliver the message during 48 hours. In case of success the status changes to “delivered”, in case of failure to deliver during 48 hours message status changes to “hard_bounced”.<br>__hard_bounced__ — failed to deliver the message, there will be no delivery attempts. It's a final status. There are a lot of possible reasons, you can use SMTP response from delivery_info.destination_response field or UniOne internal reason classification from delivery_info.delivery_status field to analyze the reason.<br>__spam__ — the message has been delivered, but it was reported as spam by the recipient. UniOne can receive and process the spam complaint from several domains, including msn.com, outlook.com, hotmail.com, live.com, ukr.net, yahoo.com, aol.com using [FBL](https://en.wikipedia.org/wiki/Feedback_loop_(email)).
     *
     * @return $this
     */
    public function setStatus(?string $status): static
    {
        if (is_null($status)) {
            throw new InvalidArgumentException('non-nullable status cannot be null');
        }
        $allowedValues = self::getStatusAllowableValues();
        if (!in_array($status, $allowedValues, true)) {
            $status = self::STATUS_UNKNOWN_DEFAULT_OPEN_API;
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets eventTime
     *
     * @return string|null
     */
    public function getEventTime(): ?string
    {
        return $this->container['eventTime'];
    }

    /**
     * Sets eventTime
     *
     * @param string|null $eventTime Event date & time in UTC time zone in **YYYY-MM-DD hh:mm:ss** format. This property exists only if event_name=**transactional_email_status**.
     *
     * @return $this
     */
    public function setEventTime(?string $eventTime): static
    {
        if (is_null($eventTime)) {
            throw new InvalidArgumentException('non-nullable eventTime cannot be null');
        }
        $this->container['eventTime'] = $eventTime;

        return $this;
    }

    /**
     * Gets url
     *
     * @return string|null
     */
    public function getUrl(): ?string
    {
        return $this->container['url'];
    }

    /**
     * Sets url
     *
     * @param string|null $url URL for **opened** and **clicked** statuses. This property exists only if event_name=**transactional_email_status**.
     *
     * @return $this
     */
    public function setUrl(?string $url): static
    {
        if (is_null($url)) {
            throw new InvalidArgumentException('non-nullable url cannot be null');
        }
        $this->container['url'] = $url;

        return $this;
    }

    /**
     * Gets deliveryInfo
     *
     * @return \UniOne\Model\WebhookSetJsonPostRequestEventsByUserInnerEventsInnerEventDataDeliveryInfo|null
     */
    public function getDeliveryInfo(): ?\UniOne\Model\WebhookSetJsonPostRequestEventsByUserInnerEventsInnerEventDataDeliveryInfo
    {
        return $this->container['deliveryInfo'];
    }

    /**
     * Sets deliveryInfo
     *
     * @param \UniOne\Model\WebhookSetJsonPostRequestEventsByUserInnerEventsInnerEventDataDeliveryInfo|null $deliveryInfo deliveryInfo
     *
     * @return $this
     */
    public function setDeliveryInfo(?\UniOne\Model\WebhookSetJsonPostRequestEventsByUserInnerEventsInnerEventDataDeliveryInfo $deliveryInfo): static
    {
        if (is_null($deliveryInfo)) {
            throw new InvalidArgumentException('non-nullable deliveryInfo cannot be null');
        }
        $this->container['deliveryInfo'] = $deliveryInfo;

        return $this;
    }

    /**
     * Gets blockTime
     *
     * @return string|null
     */
    public function getBlockTime(): ?string
    {
        return $this->container['blockTime'];
    }

    /**
     * Sets blockTime
     *
     * @param string|null $blockTime Spam block date & time in UTC time zone in **YYYY-MM-DD hh:mm:ss** format. This property exists only if event_name=**transactional_spam_block**.
     *
     * @return $this
     */
    public function setBlockTime(?string $blockTime): static
    {
        if (is_null($blockTime)) {
            throw new InvalidArgumentException('non-nullable blockTime cannot be null');
        }
        $this->container['blockTime'] = $blockTime;

        return $this;
    }

    /**
     * Gets blockType
     *
     * @return string|null
     */
    public function getBlockType(): ?string
    {
        return $this->container['blockType'];
    }

    /**
     * Sets blockType
     *
     * @param string|null $blockType Spam block type, either single or multiple sending SMTP. For single sending SMTP block in common pool UniOne retries several other SMTPs. This property exists only if event_name=**transactional_spam_block**.
     *
     * @return $this
     */
    public function setBlockType(?string $blockType): static
    {
        if (is_null($blockType)) {
            throw new InvalidArgumentException('non-nullable blockType cannot be null');
        }
        $allowedValues = self::getBlockTypeAllowableValues();
        if (!in_array($blockType, $allowedValues, true)) {
            $blockType = self::BLOCK_TYPE_UNKNOWN_DEFAULT_OPEN_API;
        }
        $this->container['blockType'] = $blockType;

        return $this;
    }

    /**
     * Gets domain
     *
     * @return string|null
     */
    public function getDomain(): ?string
    {
        return $this->container['domain'];
    }

    /**
     * Sets domain
     *
     * @param string|null $domain Domain that blocked sending. This property exists only if event_name=**transactional_spam_block**.
     *
     * @return $this
     */
    public function setDomain(?string $domain): static
    {
        if (is_null($domain)) {
            throw new InvalidArgumentException('non-nullable domain cannot be null');
        }
        $this->container['domain'] = $domain;

        return $this;
    }

    /**
     * Gets sMTPBlocksCount
     *
     * @return int|null
     */
    public function getSMTPBlocksCount(): ?int
    {
        return $this->container['sMTPBlocksCount'];
    }

    /**
     * Sets sMTPBlocksCount
     *
     * @param int|null $sMTPBlocksCount Number of sending SMTPs blocked. This property exists only if event_name=**transactional_spam_block**.
     *
     * @return $this
     */
    public function setSMTPBlocksCount(?int $sMTPBlocksCount): static
    {
        if (is_null($sMTPBlocksCount)) {
            throw new InvalidArgumentException('non-nullable sMTPBlocksCount cannot be null');
        }
        $this->container['sMTPBlocksCount'] = $sMTPBlocksCount;

        return $this;
    }

    /**
     * Gets domainStatus
     *
     * @return string|null
     */
    public function getDomainStatus(): ?string
    {
        return $this->container['domainStatus'];
    }

    /**
     * Sets domainStatus
     *
     * @param string|null $domainStatus Whether it's a block or unblock event. This property exists only if event_name=**transactional_spam_block**.
     *
     * @return $this
     */
    public function setDomainStatus(?string $domainStatus): static
    {
        if (is_null($domainStatus)) {
            throw new InvalidArgumentException('non-nullable domainStatus cannot be null');
        }
        $allowedValues = self::getDomainStatusAllowableValues();
        if (!in_array($domainStatus, $allowedValues, true)) {
            $domainStatus = self::DOMAIN_STATUS_UNKNOWN_DEFAULT_OPEN_API;
        }
        $this->container['domainStatus'] = $domainStatus;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists(mixed $offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[ReturnTypeWillChange]
    public function offsetGet(mixed $offset): mixed
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet(mixed $offset, mixed $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset(mixed $offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[ReturnTypeWillChange]
    public function jsonSerialize(): mixed
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString(): string
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue(): string
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


